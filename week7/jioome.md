# 냄새와 휴리스틱 
### 28. 조건을 캡슐화

boolean은 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

```java
// Good
if (shouldBeDeleted(timer))

// Bad
if (timer.hasExpired() && !timer.isRecurrent())
```

### 29. 부정 조건은 피하라

가능하면 긍정조건으로 표현하는 것이 이해하기 쉽다.

### 30. 함수는 한 가지만 해야 한다.

한 함수 안에 여러 단락을 이어 일련의 작업을 수행하는 것은 한 가지 일만 하는 것이 아니다.

한 가지만 수행하는 더 작은 함수 여럿으로 나눠야 한다.

```java
public void pay() {
  for (Employee e : employees) {
    if (e.isPayday()) {
      Money pay = e.caculatePay();
      e.deliverPay(pay);
    }
  }
}
```

위 함수는 세 가지 임무를 수행한다. 직원 목록을 루프로 돌고, 직원의 월급일을 확인하고, 월급을 지급한다.

이를 임무별로 3개의 함수로 나누는 것이 좋다.

```java
public void pay() {
  for (Employee e : employees) {
    payIfNeccessary(e)
  }
}

public void payIfNeccessary(Employee e) {
  if (e.isPayday()) {
    calculateAndDeliverPay(e);
  }
}

public void calculateAndDeliverPay(Employee e) {
  Money pay = e.calculatePay();
  e.deliverPay(pay);
}
```

### 31. 숨겨진 시간적인 결합

때로는 시간적인 결합이 필요하지만 이를 숨겨서는 안된다.

함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러내야 한다.

```java
public class MoogDiver {
  Gradient gradient;
  List<Spline> splines;

  public void dive(String reason) {
    Gradient gradient = saturateGradient();
    List<Spline> splines = reticulateSplines(gradient);
    diveForMoog(splines, reason);
  }
  ...
}
```

위 코드에서는 일종의 연결 소자를 생성해 시간적인 결합을 노출했다.

### 32. 일관성 유지

코드 구조를 잡을 때는 이유를 고민한다. 그리고 그 이유를 코드 구조로 명백히 표현한다.

시스템 전반에 걸쳐 구조가 일관성이 있다면 남들도 일관성을 따르고 보존한다.

### 33. 경계 조건을 캡슐화

경계 조건은 한 곳에서 별도로 처리한다. 그리고 변수로 캡슐화 하는 것이 좋다.


# 부록 A. 동시성

## ****클라이언트/서버 예제****

- 보통 클라이언트와 서버 간의 성능 테스트를 진행
- 테스트가 실패한다면 폴링을 구현한다면 모를까, 단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없음
- 속도가 느려지는 이유를 알아야 함

***폴링(polling)** : 시간을 맞추기 위하여 작업이 진행 중인 주체를 주기적으로 검사하는 작업*

### 애플리케이션에서 많은 시간이 걸리는 가능성

- I/O - 소켓 사용, 데이터 베이스 연결, 가상 메모리 스와핑 기다리기 등
- 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

해결 법 

- I/O 연산에 시간을 보내는 경우
    - **동시성**이 성능 높여주기도 함
    - 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용
- 프로세서 연산에 시간을 보내는 경우
    - 새로운 **하드웨어를 추가**해 성능을 높여 테스트를 통과하는 방식이 적합
    - 프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘인다고 빨라지지 않는다.
    - CPU 사이클은 한계가 있기 때문
    

### 결론

단일스레드 시스템에서 다중 스레드 시스템으로 변환하고, 성능을 높이기 위해서는 다음과 같은 방법을 사용

- I/O에 많은 시간을 보내야 한다.
- 관련된 코드를 분리시켜 여러개의 클래스로 분리해 **단일 책임 원칙**을 지켜야 함

## 가능한 실행 경로

```java
public class IdGenerator {
    int lastIdUsed;
    
    public int incrementValue() {
        return ++lastIdUsed;
    }
}
```

만약 IdGenerator 인스턴스는 그대로지만 스레드가 두 개라면?

- 스레드 1이 94, 스레드2가 95, lastIdUsed가 95가 된다.
- 스레드 1이 95, 스레드2가 94, lastIdUsed가 95가 된다.
- 스레드 1이 94, 스레드2가 94, lastIdUsed가 94가 된다.

### 경로 수

`return ++lastIdUsed` 는 바이트 코드 명령 8개에 해당한다.

여기서 스레드 2개가 있다면 많은 조합이 나온다. 

N개의 단계와 T개의 스레드가 있으면 가능한 경우의 수는 `(NT)! / N^T` 과 같다

```java
public synchronized int incrementValue() {
    return ++lastIdUsed;
}
```

`synchronized` 를 사용하면 가능한 경로의 수는 (스레드가 2개일 때) 2개로 줄어든다. 

스레드가 N개라면 가능한 경로의 수는 N! 이다.

### 가능한 실행 경로 2

10000개의 스레드로 현재 값인 변수에 1을 더한다고 했을 때 가정했을때,

최악의 경우는 1부터 10000까지 나올 수 있다.

이를 해결하기 위해서는 ...

### 심층 분석

- **프레임** : 모든 메서드 호출에는 프레임이 필요
    - 프레임은 호출 스택을 정의할 때 사용하는 표준 기법
- **지역 변수**
    - 메서드 범위 내에 정의되는 모든 변수를 가리킴
- **피연산자 스택** : JVM이 지원하는 명령 대다수는 매개변수를 받으며, 이 매개변수를 저장하는 장소

위 3개를 atomic 으로 잘 처리한다면 결과는 일정하다

`++` 연산은 원자적 연산이 아님 → 안전하지 않음

안전한지 판단할 수 있는 **메모리 모델 이해**가 필요 

- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법

## 라이브러리 이해

Executor 프레임 워크 

### 스레드를 차단하지 않는 방법 (non blocking)

- 최신 프로세서는 차단하지 않고 안정적으로 값 갱신
    - AtomicInteger, incrementAndGet() 등등
- 현대 프로세서는 **CAS(Compare and Swap)** 연산 지원
- 스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발
- 많은 스레드가 경쟁하는 상황이더라도 락을 거는 쪽보다 문제를 감지하는 쪽이 더 효율적

## **메서드 사이에 존재하는 의존성 조심**

추적하기 어렵지만 이를 해결하는 방안은 크게 3가지로 구성된다.

### **1. 실패를 용인하기**

### **2. 클라이언트-기반 잠금**

굉장히 위험한 전략이다.

### **3. 서버-기반 잠금**

일반적으로 가장 바람직한 방법이다.

- 코드 중복이 줄어든다.
- 성능이 좋아진다.
- 오류가 발생할 가능성이 줄어든다.
- 스레드 정책이 하나이다.
- 공유 변수 범위가 절어든다

## 데드락 발생 조건

- **상호 배제 (Mutual Exclusion)**
- **잠금 & 대기 (Lock & Wait)**
- **선점 불가 (No preemption)**
- **순환 대기 (Circular Wait)**

## 다중 스레드 코드 테스드

- 몬테 카를로 테스트 : 조율이 가능하게 유연하게 테스트를 만든다
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다
- 부하가 변하는 장비에서 테스트를 돌린다.
