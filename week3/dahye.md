
# 7장 - 오류 처리

깨끗하게 오류를 처리하는 기법과 고려사항 몇 가지 알아본다.

<br>

## 오류 코드보다 예외 사용하기
특정 함수 호출 후 오류에 대한 검증을 직접적으로 하는 것보단    
예외를 던져서 비즈니스 알고리즘과 오류를 처리하는 알고리즘을 분류하도록 한다.  
코드가 깨끗해지고 코드 품질이 좋아진다.  
- BEFORE
```java
public class DeviceController {
    public void sendShutDown() {
        DeviceHandle handle = getHandle(DEVl);
        // 디바이스 상태를 점검한다.
        if (handle != DeviceHandle.INVALID) {
            // 레코드 필드메 디바이스 상태를 저장한다.
            retrieveDeviceRecord(handle );
            // 디바이스가 일시정지 상태가 아니라연 종료한다.
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                ..
        }
        ..
        }
    }
}
```

- AFTER
```java
public class DeviceController {
    public void sendShutDown() {
        try {
            tryToShutDown() ;
        } catch (DeviceShutDownError e) {
            logger.log(e) ;
        }
    }
    
    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEVl);
        DeviceRecord record retrieveDeviceRecord(handle);
        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) {
    }
```

<br>

## Try-Catch-Finally문부터 작성하기
트랜잭션과 비슷한 try 블록문 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있고  
이는 호출자가 기대하는 상태를 정의하기 쉽게 만들고 프로그램 상태를 일관성 있게 유지시켜 준다.

<br>

## 미확인(unchecked) 예외를 사용하기
확인된 예외는 OCP(Open Closed Priciple. 로버트 마틴의 SOLID 원칙 중 하나)를 위반한다.

- OCP : 소프트웨어 구성 요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방(OPEN)되어야 하지만 변경에 대해서는 폐쇄(CLOSE)되어야 한다.

즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다.  
(모듈과 관련된 코드가 안바껴도 선언부가 바껴서 모듈을 재빌드 후 배포해야 함.)

- ex) 연쇄적인 수정의 예
최하위 함수에서 새로운 오류를 던진다고 수정하면 (확인된 오류를 정의)    
함수는 선언부에 throws절을 추가해야 하는데  
이 최하위 함수를 호출하는 함수 모두가
    - catch 블록에서 새로운 예외 처리를 하거나
    - 선언부에 thorw절을 추가해야한다.
 

학인된 예외도 유용하고 중요한 라이브러리 작성엔 모든 예외 처리가 필요하지만  
일반적인 애플리케이션의 경우,  
확인된 예외 = 의존성(비용) > 확인된예외(이익)


## 예외에 해당 에러에 대한 정보를 같이 담기
자바는 모든 예외에 호출 스택을 제공하지만 실패한 코드의 의도를 제대로 파악하려면  
애플리케이션에서 로깅 기능에서 catch 블록에서 오류를 기록하도록  
오류 메세지에 실패한 연산 이름이나 유형과 같은 정보를 담아 예외로 던진다.

<br>

## 호출자를 고려해서 예외 클래스를 정의하기
- 오류 정의 시, 오류 분류 방법
    - 오류 발생한 위치(오류 발생한 컴포넌트)
    - 유형(디바이스 실패, 네트워크 실패, 프로그래밍 오류)
    - 오류 잡아내는 방법
        1. 오류 기록한다
        2. 프로그램 계쏙 수행해도 좋은지 검증한다.

호출하는 외부 라이브러리에 대한 예외처리는  
해당 API를 감싸는 클래스를 만들고 거기서 예외를 처리한다.

- 장점
    - 외부라이브러리와 프로그램 사이에서의 의존성 줄이기 가능
    - 다른 라이브러리로 갈아탔을 때의 적은 비용
    - 감싸기 클래스에서 테스트코드만 넣어줌으로써 쉬운 테스트
    - 해당 라이브러리의 업체가 API를 설계한 방식과의 의존성 줄이기 가능

<br>

## 정상 흐름 정의 하기 - 특수사례패턴으로 예외적인 상황은 캡슐화하기
- 특수 사례 패턴(Special Case Pattern)
클래스를 만들거나 객체를 조작해서 특수사례를 처리하는 방식.

- 장점  
    클래스나 객체가 예외 상황을 캡슐화해서 처리하므로 클라이언트 코드가 처리안해도 됨

- 예제
    - BEFORE
    ```java
    try {
        MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
        m_total += expenses.getTotal();
    } catch(MealExpensesNotFound e) {
        m_total += getMealPerDiem();
    }
    ```
    - AFTER
    ```java
    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
    m_total += expenses.getTotal();

    public class PerDiemMealExpenses implements M‘V내1ea 또xpenses {
        public int getTotal() {
            // 기본값으로 일일 기본 식비 반환
        }
    }
    ```
    
<br>

## null을 반환하거나 전달하지 말기
- 반환하는 것
    - null에 대한 처리 필요
    - 호출자에게 문제 떠넘기는 방식(null 확인 빠뜨리면 어플리케이션 전체가 불안정해질 수 있음)
    - 대안
        - 예외 던지기
        - 특수사례 객체 반환
        - 외부 API가 null 반환 시, 감싸기 메서드를 구현해서 예외 던지기/특수사례 객체 반환

- 전달하는 것
    - 인수로 null이 넘어오면 코드에 문제가 있다는 것
    - 대안
        - 새로운 예외 유형 던지기
        - assert문 사용
    - null을 적절히 처리하는 방법은 없으므로 애초에 null 전달 안하도록 하는 게 중요  

<br>

## 결론
오류 처리를 프로그램 논리와 분리하면  
    - 꺠끗한 코드 작성 가능  
    - 독립적인 추론 가능  
    - 코드 유지보수성 크게 개선  

<br>


----

# 8장 - 경계

시스템에 들어가는 외부 코드와 우리 코드에 존재하는 소프트웨어 경계를 깔끔하게 처리하는 기법을 알아보자.

- 패키지/프레임워크 제공자
    - 적용성(범용성)을 최대한 넓히려 애씀. 많은 고객 확보
- 사용자
    - 자기네의 프로그램에서의 요구에 집중하는 인터페이스를 바람

<br>

## ex) java.util.Map
많은 인터페이스로 수많은 기능을 제공하고 유연성도 크지만   
메서드를 사용하는 데에 권한이 따로 없고 올바른 유형으로 변환할 책임은 온전히 사용자에게 있음.  
즉, 아무나 함수를 쓸 수 있꼬 타입 에러가 날 수도 있음.
- 대안
    - 제네릭  
    단, 사용자에게 필요하지 않은 기능까지 제공한다는 문제는 해결 못함.
    - 경계 인터페이스를 새로운 클래스 안으로 숨기거나 ADAPTER 패턴 사용        
        - 목적
            - 경계 인터페이스(여기선 Map)를 사용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의하기 위함.
            - 해당 경계 인터페이스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않도록 하기 위함
            - 경계 인터페이스에서 사용되는 객체 유형을 관리하고 변환하기 위함
        - 장점
            - 사용자는 제네릭스가 사용됐는지 신경쓸 필요 없다.
            - 경계 인터페이스가 변경돼도 나머지 프로그램에는 영향을 미치지 않음.
            - 코드 가독성 높아짐
            - 경계 인터페이스를 사용하는 일관성도 높아짐
            - 외부 패키지가 변했을 때 변경할 코드도 줄어듦

<br>

## 경계에 대한 테스트 코드 작성  
외부 패키지 테스트의 책임은 우리가 안지지만 우리가 사용하기 위한 코드를 테스트하는 편이 좋다.  

- 일반적인 테스트 방법
    1. API 문서 정독
    2. 우리쪽 코드 작성해서 라이브러리 동작 확인
    3. 버그 판단한다고 디버깅 시간 한참 쓰기

- 학습 테스트  
    우리쪽 코드를 작성해서 호출하는 대신,  
    먼저 간단한 테스트 케이스를 작성해서 외부코드를 익히는 방법  
    - 장점  
        - 프로그램에서 사용하려는 방식대로 외부 API를 호출하면서  
        통제된 환경에서 API를 제대로 이해하는지에 대해 확인할 수 있다.
        - 필요한 지식만 확보할 수 있다.
        - 외부 라이브러리에 대한 이해도를 높여준다.
        - 투자 노력 < 얻는 성과
        - 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하기 때문에  
        패키지 새 버전이 나오면 예상대로 패키지가 도는지 검증할 수 있는 경계 테스트가 있다면  
        패키지 새 버전으로 이전하기 쉬워진다.

<br>
      
## 결론
- 소프트웨어 설계가 우수하다면 변경하는 데에 많은 투자와 재작업이 필요하지 않다.
- 경계에 위치하는 코드는 깔끔히 분리하고 기대치를 정의하는 테케도 작성한다.
- 통제가 불가능한 외부 패키지에 의존해서 외부 코드에 휘말리는 대신 통제가 가능한 우리 코드에 의존하는 게 훨씬 좋다.
- 외부 패키지를 호출하는 코드를 가능한 줄여서 경계를 관리하자

<br>

----

# 9장 - 단위테스트

<br>


----

# 10장 - 클래스
- 클래스명은 해당 클래스 책임을 기술해야한다. 작명은 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 클래스 크기가 큰, 즉 책임이 너무 많아서다.

- SW를 돌아가게 하는 것과소프트웨어를 꺠끗하게 만드는 활동은 완전히 별개다. 전자가 초점이지만 전적으로 올바른 태도는 후자여야한다. 관심사를 분리하는 작업은 프로그램과 프로그래밍활도에서 중요하다.
- 도구 상자로서 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은지 아니면 큰 서랍 몇개를 두고 모두 던져놓고 싶은지?

- 규모가 복잡한 시스템은 논리가 많다. 이럴 때일수록 체계적인 정리가 필수다.  
그래야 개발자가 뭐가 어딨는지 찾고 변경할 떄 직접 영향이 미치는 ㅋ넘포넌트만 이해해도 충분하다. 큼직한 다목적 클래스 몇개로 이뤄진 시스템은 변경할 때 당장 알 필요없는 사실까지 보면서 이해에 방해함.

- 함수를 작게, 매개변수 목록 짧게 전략을 따를 때,  
몇몇 메서드만이 사용하는 인스턴스 변수가 많아지게 되는데 이때는 새로운 클래스로 쪼개야 한다는 신호다.  
응집도가 높아지수록 변수와 메서드를 적절히 분리해서 새로운 클래스 두세개로 쪼개준다.

시스템 결합도,응집도를 낮추면
- 유연성, 재사용성 증가
- 각 시스템 요소가 다른 요소/변경으로부터 잘 격리되어있으므로 각 요소 이해에 용이
- DIP(Dependency Inversion Pricniple. 상세한 구현이 아닌 추상화에 의존하는 원칙) 따르는 클래스 나옴

