## `**chapter**` **7장 오류 처리**

---

- 간단히 말해, 뭔가 잘못될 가능성은 늘 존재한다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다. 깨끗한 코드와 오류 처리를 확실히 연관성이 있다.
- 오류 코드보다 예외를 사용하라
- Try-Catch-Finally 문부터 작성하라
    
    어떤 면에서 try 블록은 트랜잭션과 비슷하다. 따r블록에서 무슨 일이 생기든 지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다.
    
- 오류를 원거리에서 처리하기 위해 예외를 사용한다는사실을 감안한다면 이처럼 확인된 예외가 캡슐화를 깨버 리는 현상은 참으로 유감스럽다.
- 호출자를 고려해 예외 클래스를 정의하라
오류를 분류하는 방법은 수없이 많다. 오류가 발생한 위치로 분류가 가능하다. 예를 들어 오류가 발생한 컴포넌트로 분류한다. 아니면 유형으로도 분류가 가능하다. 예를 들어 디바이스 실패， 네트워크 실패， 프로그래밍 오류 등으로 분류한다. 하지만 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야한다.
- 마지막 장점으로 감싸기 기법을 사용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 프로그램이 사용하기 편리한 API를 정의하면 그만이다.
- null을 반환하지 마라
그 중 첫째가 null을 반환하는 습관이다. 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션을 지금까지도 수도 없이 봤다. 다음이 한 예다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6fe6ea53-0d7e-4baf-9863-d180bc97626f/Untitled.png)
    
- 다행스럽게 자바에는 Collections.emptyList()가 있어 미리 정의된 읽기 전용 리스트를 반환한다. 이렇게 코드를 변경하면 코드도 깔끔해질뿐더러 NPE를 발생한 가능성도 줄어든다.
- null을 전달하지 마라
    
    메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.
    대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적 이다. 즉,인수로 null이 넘어오면 코드에 문제가 있다는 말이다. 이런 정책을 따 르면 그만큼 부주의한 실수를 저지를 확률도 작아진다.


## `**chapter**` **8장 경계**

---

- 학습 테스트
우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것
- 깨끗한 경계
경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 이쪽 코드에서 외부 패키지를 세세하게 알아야 할 필요가 없다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 오히려 외부 코드에 휘둘리고 만다.

## `**chapter**` **9장 단위 테스트**

---

- TDD 법칙 세가지
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 테스트에 쏟아 부은 노력은 확실히 허사였다. 하지만 실패를 초래한 원인은 테스트 코드를 막 짜도 좋다고 허용한 결정이었다. 테스트 코드를 깨끗하게 짰다면 테스트에 쏟아 부은 노력은 허사로 돌아가지 않았을 터이다.
- 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
- 어쩌면 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다. 테스트 코드에서 가독성을 높이려면? 여느 코드와 마찬가지다. 명료성, 단순성, 풍부한 표현력이 필요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.
- 테스트 당 개념 하나
    
    어쩌면 “테스트 함수마다 한 개념만 테스트하라”는 규칙이 더 낫겠다. 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다.
    
- F.I.R.S.T
빠르게Fast; 테스트는 빨라야 한다.
독립적으로Independent; 각 테스트는 서로 의존하면 안 된다.
반복가능하게 Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다
자가검증하는Self-Validating: 테스트는 부울bool 값으로 결과를 내야 한다.
적시에Timely: 테스트는 적시에 작성해야 한다.

## `**chapter**` **10장 클래스**

---

- 클래스는 작아야 한다.
클래스를 만들 때 첫 번째 규칙은 크기다. 클래스는 작아야 한다. (…) 함수는 물리적인 행 수로 크기를 측정했다. 클래스는 다른 척도를 사용한다. 클래스가 맡은 책임을 센다.
- 클래스 이름은 해당 클래스 책임을 기술해야한다 실제로 작명은 클래스크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다. 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다. 예를 들어， 클래스 이름에 Processor,Manager,Super 등과 같이 모호 한 단어가 있다면 클래스에다 여러 책임을 떠안겼다는 증거다.
- 그러므로 고민할 질문은 다음과 같다. “도구 상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍 몇 개를 두고 모두를 던져 넣고 싶은가?”
- 강조하는 차원에서 한 번 더 말하겠다. 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템이 필요한 동작을 수행한다.
- 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미이기 때문이다. (…) 클래스가 응집력을 잃는다면 쪼개라!
- OCP란 클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙이다.
- 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다. 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.