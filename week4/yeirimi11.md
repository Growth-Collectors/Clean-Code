Clean-Code_week4_yerimi11
(수정 중)

관심사 분리를 하지 않고 런타임 로직과 객체 생성 로직이 섞이는 경우, 단일 책임 원칙(Single Responsibility Principle)이 깨질 수 있다.  
<img width="309" alt="image" src="https://github.com/Growth-Collectors/Clean-Code/assets/93559998/2ce1cf3f-599f-47e8-9081-435f7903a36b">

좋은 설계를 위해서는 객체 생성과 관련된 로직은 별도의 팩토리나 생성자 등의 메서드로 분리하여 단일 책임을 갖는 별도의 클래스로 위임하는 것이 좋다.  
이를 통해 코드의 응집도를 높이고 유지보수성을 향상시킬 수 있다.  

체계적이고 탄탄한 시스템을 만들고 싶다면 모듈성을 깨서는 절대로 안 된다.  
객체를 생성하거나 의존성을 연결할 때도 마찬가지다.  
설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.  
또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.  

- main()에서 생성 분리: 시스템 생성과 시스템 사용을 분리하는 방법  
- 팩토리로 생성 분리: 객체가 생성되는 시점을 애플리케이션이 결정하는 방법 ex) 주문처리 시스템(추상 팩토리 패턴)  
  ㄴ 추상 팩토리 패턴: 생성할 객체의 종류에 따라 다양한 구체적인 팩토리 클래스를 만들고, 클라이언트가 이러한 팩토리를 사용하여 객체를 생성할 수 있도록 한다.  
- 의존성 주입(DI:Dependency Injection): 제어 역전(Inversion of Control, IoC)기법을 의존성 관리에 적용한 메커니즘. 설정자(setter) 메서드나 생성자 인수 혹은 둘 다를 제공한다.  
  ㄴ 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기고, 새로운 객체를 넘겨받은 책임만 맡으므로 단일 책임 원칙(SRP)을 지키게 된다.

  
