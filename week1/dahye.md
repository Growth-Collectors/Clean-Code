깨끗한 코드를 작성하는 방법은 어렵기 때문에 많은 정성이 필요하다.  
이 책에서는  뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개한다.  

- 이 책의 구성과 이해하는 방법
1. 원칙,패턴,실기에 대한 설명을 이해해야한다.
2. 코드를 읽고 설명과 접목시켜 이해하고 코드에 대한 변경과 이유를 납득해야한다.
3. 사례 연구에서 코드를 정리하면서 내려진 결졍과 휴리스틱 사이의 관계를 이해해야 한다.

# 1장 - 깨끗한 코드
- 모델이나 요구사항에 집중하는 것도 중요하지만 
코드는 요구사항을 표현하는 언어이기 때문에 가장 기저가 된다.
- 나쁜 코드는 나쁜 코드를 유발한다 = 고행(wading)
안돌아가는 프로그램보다 돌아가는 쓰레기가 좋다고, 유지보수는 나중으로 미루는 것은 르블랑의 법칙(나중은 결코 오지 않는다)을 모르고 말하는 것
- 나쁜 코드의 특징
    - 개발속도를 크게 떨어뜨림
    - 더러워진 코드를 해독해서 또 얽힌 코드를 더하게 됨
    - 설계 의도와 맞는 변경과 의도에 반하는 변경을 구분하지 못함
    - 팀 생산성 떨어짐
=> 시간들여서 깨끗한 코드를 만드는 노력은 비용을 절감하고 전문가로서 살아남게 해준다.
- 코드가 엉망이라 예상한 업무가 늘어진 경험, 한줄 고치려 했따가 모듈 수백개 건드린 경험..
나쁜 코드가 되는 이유는 요구사항이 변하거나 일정이나 고객의 문제가 아니라 프로그래머 탓이다.
나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가 답지 못함..
- 기한에 맞추려면 나쁜 코드를 양산할 수 밖에 없다. 따라서 애초부터 코드를 깨끗하게 유지하는 습관을 들이는 게 필요하다.  
청결함으로 자잘한 기법들을 적용하는 절제와 규율이 필요하다.  
- 깨끗한 코드의 정의
    - 비야네 스트롭스트룹
        - 우아하고 효율적인 코드 - 단순하고 보기에 즐거운 코드
        - 속도와 오류처리, 메모리 누수, 경쟁상태, 명명법 등에 대한 세세한 사항까지 처리하는 코드
        - 의존성이 낮고 한 가지를 잘 하는 코드(나쁜 코드는 많은 일을 처리하게 돼서 의도와 목적이 흐려짐)
    - 그래디 부치
        - 가독성 있는 코드 - 단순하고 직접적
        - 설계자 의도가 보이는, 사실에 기반한 코드
    - 데이브 토마스
        - 작성자가 아닌 사람도 읽고 고치기 쉬운 코드
        - 테스트케이스가 존재하는 코드 - 큰 코드보다 작은 코드에 가치를 둔다.
    - 마이클 펟스
        - 주의 깊게 짰다는 느낌을 주는 코드
    - 론 제프리스
        - 모든 테스트케이스를 통과한 코드
        - 중복이 없고 제대로된 표현력 - 문제의 아이디어, 의미있는 이름, 객체나 메서드에 대해 중복이 없고 시스템 내 모든 설계 아이디어를 표현한 코드
        - 작게 추상화 - 클래스, 메서드, 함수 등을 최대한 줄인 코드 - 추상 메서드/클래스로 실제 구현을 감싸면(추상화) 간단한 기능 구현에만 집중하고 나머지 기능 구현에 신경쓰지 않아도 된다.
    - 워드 커닝햄
        - 각 루틴이 그대로 수행되는 코드 - 모든 것이 예상 가능한 것
    - 책 저자
        - 기본 코드를 잘 읽고 읽기 쉽게 코드를 짜면 된다.
        - 체크아웃 할 때보다 좀 더 꺠끗한 코드를 체크인 해야 한다.

# 2장 - 의미 있는 이름
이름을 잘 짓는 간단한 규칙을 소개한다.

## 의도가 분명한 이름
변수, 클래스, 메소드에 대한 작명 시간이 걸리지만 이를 통해 앞으로 절약하는 시간이 많아진다.
- 작명 시, 고려 조건
    - 존재 이유
    - 수행 기능
    - 사용 방법
코드의 단순함이 아닌 코드의 함축성이 중요하다.  
(코드의 맥락이 코드 자체에 명시적으로 드러나야한다.)

## 그릇된 정보는 피하기
- 널리 쓰이는 의미의 단어를 다른 의미로 쓰지 않기
- 컨테이너 유형을 이름에 넣지 말기
- 흡사한 이름을 사용하지 않도록 하기
- 일관성이 떨어지는 표기법을 쓰지말기

## 의미있게 구분하기
- 잘못된 구분
    - 철자만 바꾸는 방식
    - 연속된 숫자를 덧붙이거나 불용어(info,data,a,an,the)를 추가하는 방식 - 아무 정보를 제공하지 못하고 중복을 내포함

## 발음하기 쉬운 이름
약어의 합성어는 의사소통할 때나 인수인계할 때 어렵게 한다.
`genymdhms - generate date, year, month, day, hour, minute, sec-ond`
=> `generationTimestamp`

## 검색하기 쉬운 이름
문자 하나를 사용하는 이름과 상수는
고유하게 사용되는 것이 아니라 텍스트 코드에서 쉽게 눈에 띄지 않는다.
=> 의미가 분명한 경우에 한해서 긴 이름, 검색하기 쉬운 이름이 짧은 이름과 상수보다 좋다.
그렇지 않으면 의미를 분석해서 원하는 상수를 가려내야 한다.
`5 => WORK_DAYS_PER_WEEK`

## 인코딩을 피하라
- 유형/범위정보까지 인코딩에 넣으면 이름 해독에 어려워진다.  
예전에는 컴파일러가 타입을 점검하지 않았어서 타입을 기억할 단서로 변수 이름에 타입을 인코딩했다. (헝가리식 표기법)
요즘은 언어에서 많은 타입을 지원하고 컴파일러가 타입을 기억하고 강제한다.
또 객체는 강한 타입이고 IDE는 코드를 컴파일하지 않고도 타입 오류를 감지할 정도로 발전했다.
- 멤버변수에 접둥를 붙일 필요가 없다. 클래스와 함수는 접두어가 필요없을 정도로 작아야한다. 그리고 접두어는 그렇게 사람들이 신경쓰징 않음
- 인터페이스 클래스 이름(`CShapeFactory`)과 구현 클래스 이름(`SHapeFactoryImpl`) 중 하나를 인코딩 해야한다면 구현 클래스 명이 더 낫다.

## 자신이 아는 이름으로 작명하지마라
루프문에서 루프 범위가 아주 작고 다른 이름과 충돌하지 않는 상황에서 반복 횟수를 세는 변수를 제외하고는 문자 하나만 사용하는 변수명은 문제가 있다.
명료함이 최고라는 사실을 이해야한다.

## 클래스/객체/메서드명
- 클래스,객체명 - 명사나 명사구. 동사를 사용하지 않아야함
- 메서드명 - 동사나 동사구.
    - 생성자를 중복정의할 때는 정적 팩토리 메서드를 사용해야한다.메서드 명은 인수를 설명한다.(오른쪽 메서드명이 더 좋음)
    `Complex fulcrumPoint = nex Complex(23.0) -> Complex.FromRealNumber(23.0)`

## 기발한 이름은 피하기
재미난 구어체나 속어를 사용하기 보단 의도가 분명한 명료함을 택하라.

## 1개념1단어를 사용해라
추상적인 개념 하나에 대해 하나의 단어를 선택해야한다.  
메서드명은 독자적이고 일관적이어야 사용할 메서드를 선택할 떄 주석을 안보고도 올바르게 가능하다.  
`Controller, Manager, Driver` => `DeviceManager, ProtocolController` (X)  
왜 다른지, 어떤 게 다른지에 대해 의문을 품게 되고 클래스와 타입도 다르다고 생각하게 됨..

## 말장난을 하지 말 것
한 단어를 두가지 목적으로 사용하지마라.  
즉, 다른 개념에 같은 단어를 사용하는 것은 말장난이다.
ex) 여러 클래스에 add라는 메서드가 있을 경우,   
모든 add 메서드의 매개변수와 반환값이 의미적으로 같다면 상관없지만 아니라면 insert나 append 이름을 붙여줘야한다.  
코드를 최대한 이해하기 쉽게 짜야하고 의도를 명료하게 밝혀주는 것이 개발자의 몫이다.  

## 해법 영역과 문제 영역에서 가져온 이름을 사용해라
전산용어, 알고리즘명, 패턴명, 수학용어 등 프로그래머가 이해할 수 있는 해법 영역에서의 이름을 사용하되,
적절한 프로그램 용어가 없다면 문제 영역에서의 이름을 사용한다.    
그럼 해당 분야의 전문가에게 의미를 물어 파악할 수 있다.  

## 의미 있는 맥락을 추가하라
클래스, 함수, 이름에 맥락을 부여해서 의미를 분명하게 하되, 그럼에도 의미 부여가 안되면 접두어를 붙인다.

## 불필요한 맥락을 없애라
- 고급휘발유충전소(GSD. GasStationDeluxe)라는 어플리케이션의 개발에서
모든 클래스명을 GSD로 시작한다면 IDE에서 G 입력 후 자동완성 키 누르면 모든 클래스를 열거할 것이기 때문.
- GSD 회계 모듈에 MailingAddress 클래스를 추가하면서 GSDAccountAddress로 이름을 바꿨다면,
다른 고객 관리 프로그램에서 고객주소가 필요할 때 해당 클래스를 사용하냐 한다면 이름 17자 중 10자는 중복이거나 부적절하다.

## 요약
좋은 이름을 징르 때는 뛰어난 설명 능력이 필요하고 문화적 배경이 같아야 한다.
암기는 IDE에 맡기고 문장이나 문단처럼 읽히는 코드가 아니면(정보 표시의 최선이 항상 문장은 아니니까) 적어도 표나 자료구조처럼 읽히는 코드를 짜는 데에 집중해야한다.

# 3장 - 함수
함수를 잘 만드는 법

## 작게 만들 것
바깥을 감싸는 함수가 작아지고
블록 안에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해하기도 쉬워진다.
즉, 중첩 구조가 생길만큼 함수가 커져서는 안되고
함수에서 들여쓰기 수준은 1,2단을 넘어서면 안된다.

## 한 가지 기능만 담을 것
지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행하도록 하는 것.  
함수를 만드는 이유가 큰 개념(함수이름)을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위함.  
의미 있는 이름으로 다른 함수를 추출할 수 있따면 여러 작업을 하는 셈이다.  
- EX)
    1. 페이지가 테스트 페이지인지 판단
    2. 그렇다면 설정, 해제 페이지를 넣는다.
    3. 페이지를 HTML로 렌더링한다.

-  HOW TO
함수 내 모든 문장의 추상화 수준이 동일해야 한다. (DIFFICULT, BUT IMPORTANT)
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 특정 표현이 근본 개념인지 구분하기 어려워진다.
이후에는 사람들이 '깨진 창문'처럼 함수에 세부사항을 점점 더 추가하게 되어 악화된다.

- 내려가기 규칙 - 위에서 아래로 코드읽기
위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 단계씩 낮아지는 것.
=> 이를 통한 코드 구현은 추상화 수준을 일관되게 유지하기 쉬워진다.

## Switch문
```java
public Money calculatePay(Employee e) throws InvalidEmployeeType{
    swtich(e.type){
        case :
            return
        case :
            return;
        case :
            return;
        default :
            return;
    }
}
```
- 문제점
    - 긴 함수
    - 한 가지 작업만 수행하지 않음
    - SRP(Single Responsibility Priciple) 위반 - 코드 변경할 이유 많음
    - OCP(Open Closed Priciple) 위반 - 새 직원 유형 추가할 때마다 코드 변경

본질적으로 N가지 작업을 해야하는 Switch문은 각각을 다형성을 이용해서 저차원 클래스에 숨기고 절대 반복하지 않도록 해야한다.

- HOW TO
    다형성 객체를 생성하는 코드 안에서 switch문을 추상팩토리(ABSTRACT FACTORY)에 숨기고 다른 코드에 노출하지 않게 한다.


## 서술적인 이름을 사용해라
함수가 작고 단순할수록, 길고 서술적인 이름을 고르기도 쉽다.(길고 서술적인 주석보다 나음)
단, 이름을 붙일 때는 모듈 내에서 함수 이름은 같은 문구,명사,동사를 사용해서 일관성이 있어야 한다.

- HOW TO 명명
1. 여러 단어가 쉽게 읽히는 명명법을 사용한다.
2. 여러 단어를 사용해서 함수 기능을 잘 표현하는 이름을 선택한다.

- 장점
    - 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하는 게 쉬워진다.

## 함수 인수
- 인수 개수의 관점
이상적                   특별한 이유 필요
0개 --   1개 -- 2개 -- 3개 -- 4개
(최선)  (차선)

- 함수 인수가 어려운 이유
    - 인수를 발견할 때마다 의미를 해석해야한다.  
    함수명과 인수 사이에 추상화 수준이 다르다.
    - 테스트 관점에서는 2개 이상일 떄부터 갖가지 인수 조합으로 함수를 검증하는 테케를 작성해야한다.
    - 출력인수(함수에다가 인수를 입력으로 넘기고 반환값으로 출력 받는 것)의 경우, 대개 함수에서 인수로 결과를 받으리라고 생각하지 않으므로 독자가 코드를 재차 확인하게 만듬.

- 단항 형식
    - 사용하는 경우 - 함수에 인수 1개를 넘기는 경우
        - 하나의 인수에 대해 질문을 던지는 경우 - `boolean fileExists("MyFile")`
        - 인수를 다른 걸로 변환해서 결과를 반환하는 경우 - `InputStream fileOpen("MyFile") => String 형의 파일 이름을 InputStream으로 변환`
        - 이벤트 함수 - 유용한 단항 함수 형식
            - 입력 인수만 있고 출력 인수는 없음.
            - 함수 호출을 이벤트로 해석해서 입력 인수로 시스템 상태를 바꾸는 방식
            - 이벤트라는 사실이 코드에 드러나야 하므로 이름과 문맥을 주의해서 선택해야 한다.
    위의 경우가 아니면 가급적 피하는 게 좋다.
    - 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.  
    - 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
    - 입력 인수를 그대로 돌려주는 함수라도 적어도 변환 형태를 유지하기 때문에 변환 함수 형식을 따르는 편이 좋다.
        `StringBuffer trasnform(StringBuffer in) -> void trasnform(StringBuffer out)`

- 플래그 인수
최악 - 플래그의 참,거짓에 따라 여러가지를 처리한다는 말이니까

- 이항 함수
이항 함수가 나쁜 건 아닌데 해독이 필요하단 걸 인지하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
단, 인수 2개가 한 값을 표현하는 두 요소거나 인수 내에서 자연적인 순서가 있다면 이항 함수가 적절하다.
    - 좋은 예 - `Point p = new Point(0,0)`
    - 나쁜 예 - `assertEquals(expected, actual)`

- 삼항 함수
더 어려움...

- 인수 객체
인수 2-3개가 필요할 때 일부를 독자적인 클래스 변수로 선언할 수도 있다.
`Circle makeCircle(double x, double y, double radius) -> Circle makeCircle(Point center, double radius)`
변수를 묶어 넘기려면 이름을 붙여야 돼서 개념을 표현하게 된다.

- 인수 목록
인수 개수가 가변적인 함수
ex) `public String format(String format, Object... args)`
가변 인수 전부를 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다.
가변 인수를 취하는 함수는 단/이/삼항 함수로 취급할 수 있지만 이를 넘어서는 인수를 사용할 경우에는 문제가 있다.

- 동사와 키워드
    - 단항 함수는 함수와 인수가 동,명사 쌍을 이뤄야 한다. - `write(name) 이름이 무엇이든 쓴다 -> writeField(name) 이름이 필드`
    - 함수 이름에 키워드를 추가하는 형식이다. 즉, 함수 일므에 인수를 넣는다. - `assertEquals -> assertExpectedEqualsActual(expected, actual)`

## 부수효과를 일으키지 마라
함수에서 한 가지를 기능하게 해도 예상치 못한 나비효과를 일으킨다.
- 클래스 변수를 수정
- 함수로 넘어온 인수나 시스템 전역 변수를 수정
- 시간적인 결합(temporal coupling)
- 순서 종속성(order dependency)
사용자가 부수효과까지 인지할 수 있도록 함수가 일으키는 부수효과도 함수명에 드러나도록 해야한다
`checkPassword -> checkPasswordAndInitializeSession`(함수가 한가지만 한다는 규칙은 위반함)

- 출력인수
    피하는 것이 좋다.
    - 함수 선언부를 찾고나서야 인수의 역할을 제대로 알기 때문
    함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택해야한다.

## 명령과 조회를 분리해라
함수는 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나만 해야한다.
만약 공존한다면 명령과 조회를 분리해야한다.
`if( set("username", "unclebob") ).. -> if( attributeExists("username) ){ setAttribute("username", "unclebob"); .. }`

## 오류 코드보다 예외를 사용해라
명령 함수에서 오류 코드를 반환하는 방식 == 자칫 if문에서 명령을 표현식으로 사용하기 쉽기 때문에 명령/조회 분리 규칙을 미묘하게 위반한다.
`if(deletePage(page) == E_OK)`
=> 동사/형용사 혼란을 일으키지 않는 대신, 여러 단계로 중첩되는 코드를 야기한다.  

- 오류 코드를 반환하는 경우
호출자는 오류 코드를 바로 처리해야한다는 문제점이 있다.
=> 대안  
오류 코드 대신, 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리돼서 코드가 깔끔해진다.

- Try/Catch 블록 추출
코드 구조에 혼란을 일으켜서 정상 동작과 오류 처리 동작을 뒤섞어서 추한 코드이므로 이를 방지하기 위함
정상동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.

- 오류 처리도 한 가지 작업에 속함
오류를 처리하는 함수는 오류만 처리해야 마땅하다.
함수에 키워드 try가 있다면 catch/finally로 끝애야 함.

- Error.java 의존성 자석 클래스
오류 코드를 반환한다 == 클래스/열거형변수든 어디선가 오류 코드를 정의한다
Error enum을 다른 클래스에서 import 해서 사용할텐데 의존성이 높다.
재컴파일/재배치가 번거롭기 때문에 새 오류를 추가하는 대신, 예외를 사용하면 기존 오류 코드를 재사용 할 수 있다.
즉, 새 예외는 Exception 클래스에서 파생되므로 해당 작업들 없이 새 예외 클래스를 추가할 수 있다.

## 반복하지마라(DRY. Don't Repeat Yourself)
반복되는 알고리즘은 코드 길이가 늘어나고 수정할 때마다 쓰인 곳 모두에 수정해줘야하고(그렇지 않으면 에러 발생할 확률도 그 만큼 증가)

## 구조적 프로그래밍
- 데이크스트라의 구조적 프로그래밍 원칙
"모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다." => return 문이 하나여야함.
단일 입/출구 규칙을 적용하되, 함수가 클 떄는 goto(하지만 자제), 함수가 작을 때에만 return, break, continue를 여러 차례 사용할 순 있다.

## 요약
모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인특화언어(DSL)로 만들어진다.
대가 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다.
시스템에서 발생하는 모든 동작을 설명하는 함수 계층이 그 언어이고
언어를 길이가 짧고 이름이 좋고 체계가 잡히게 만들어서 좋은 시스템에 뒷받침 하기 위함.
