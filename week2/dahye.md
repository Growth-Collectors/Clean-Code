# 4장 - 주석
- 주석이 별로인 이유 - 오래될수록 코드에서 멀어지고 오래될수록 잘못될 가능성도 커진다. 코드를 유지보수한다고 주석까지 유지보수한다는 보장이 없음.
- 코드에 주석을 추가하는 이유 - 코드 품질이 나빠서
- 프로그래밍 언어로 의도를 표현할 능력이 있으면 주석은 전혀 필요하지 않다.
- 필요하다 느껴지면, 상황을 역전햇 코드로 의도를 표현할 생각을 해야한다.
- 주석 달 때마다 자신에게 표현력이 없다는 사실 인지..
- 주석을 엄격하게 관리하는 것도 방법이지만 그보단 코드를 깔끔하게 정리하고 표현력을 강화해서 아예 주석이 없게끔 하는 게 최선이다

```java
// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.
if( (employee.flags&HoURLY_FLAG) && (employee.age>65) ) (X)
```
```java
if( employee.isEligibleForFullBenefits() ) (O)
```

## 좋은 주석
최선은 주석 안다는 거지만 쓴다면 도움이 되는 주석들
하지만 오도, 잘못 위치, 그릇된 정보 전달 가능성은 있음

1. 법적인 주석 
회사가 정립한 구현 표준에 맞춰서 넣는 주석
ex - 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보, 소유권 정보 - Copyright..

2. 기본적인 정보를 제공하는 주석
```java
// kk:mm:ss EEE, MMM dd, yyyy 형식이다.
Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*");
```
구체적으로는 주어진 형식 문자열을 사용해 SimpleDateFormat. format 함수가 반환하는 시각과 날짜를 뜻한다.
이왕이면 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 좋고 더 깔끔하겠다. 그러면 주석이 필요 없어진다.

3. 구현에 대한 이해를 돕고 의도를 설명하는 주석
알고리즘,...

4. 의미를 명료하게 밝히는 주석
인수나 반환값이 개발자가 자체적으로 만드는 게 아니라 표준 라이브러리나 변경하지 못하는 코드에 속하는 경우에 유용.

```java
assertTrue(a.compareTo(a) Ø); // a == a
assertTrue(a.compareTo(b) != Ø); // a != b
assertTrue(ab.compareTo(ab) == Ø); // ab == ab
assertTrue(a.compareTo(b) == -1); // a < b
assertTrue(aa.compareTo(ab) == -1); // aa < ab
assertTrue(ba.compareTo(bb) == -1); // ba < bb
assertTrue(b.compareTo(a) 1); // b > a
assertTrue(ab.compareTo(aa) 1); // ab > aa
assertTrue(bb.compareTo(ba) == 1); // bb > ba
```
5. 결과를 경고하는 주석
Junit4 전에는 이름 앞에 _를 붙이는 게 일반적이었지만  
요즘은 @Ignore 속성을 이용해서 테케를 꺼버리기도 하고 구체적인 설명은 속성에 문자열로 넣어줄 수 있기도 함
`@Ignore("실행이 너무 오래걸림")`

6. TODO 주석
당장 구현하기 어려운 업무들에 대한 것. 하지만 떡칠은 금지
- 더 이상 필요 없는 기능을 삭제하라는 알림
- 누군가에게 문제를 봐달라는 요청
- 더 좋은 이름을 떠올려달라는 부탁
- 앞으로 발생할 이벤트에 맞춰 코드를 고치라는 주의

7. 중요성을 강조하는 주석
8. 공개 API에서 Javadocs

## 나쁜 주석
대다수의 주석이 속하는 범주.

1. 주절거리는 주석  
쓰다만 것 같이 정성을 들이지 않은 주석.  
답을 알아내려면 다른코드를 뒤져보는수밖에 없다.  
이해가 안돼서 다른 모듈까지 뒤져야 하는 주석은 독자와 제대 로 소통하지 못하는 주석이다.  
그런 주석은 바이트만 낭비할 뿐이다.

2. 같은 이야기를 중복하는 주석
코드 내용을 코드가 아닌 말로 주석으로 기재해놓는 것.  
코드만 지저분하고 정신없게 만듦.  
` 이 컴포넌트의 프로세서 자연값 , 컨테이너와 관련된 Loader 구현`

3. 오해할 여지가 있는 주석  
코드랑 조금 다르게 해석해놓은 주석 때문에 개발자가 잘못된 액션을 할 수 있음  
`코드는 true여야 메서드 반환하는 건데 주석은 true로 변하는 순간에 메서드 반환된다고 적는 것`

4. 의무적으로 다는 주석  
`CD 제목, CD 저자, CD 트랙 숫자, ..`

5. 이력을 기록하는 주석  
이젠 소스 코드 관리시스템이 있다

6. 있으나 마나 한 주석, 혼잣말 주석  
`기본 생성자, 월 중 일자를 반환한다`  
이런 것만 있으면 코드 읽으면서 주석 건너띄는 습관이 생김  

7. 무서운 잡음  
`JavaDocs로 문서 제공해야한다는 강박에서 탄생한 잡음`

8. 함수나 변수로 표현할 수 있다면 주석을 달지말기 

9. 위치를 표시하는 주석  
` // Actions //////////////// `  
저거 아래에 특정 기능 모아두거나 환기용으로 한번만 쓰면 유용하지만 일반적인 경우에는 가독성만 낮추므로 자제

10. 닫는 괄호에 다는 주석  
`for{}//for`   
닫는 괄호에 주석 달아야겠딴 생각 들면 함수 줄이려 시도하기 => 함수 길어지면 내가 하는 거

11. 공로를 돌리거나 저자를 표시하는 주석  
`xx가 추가함`  
소스코드관리시스템이 한다.
 
12. 주석으로 처리한 코드  
이건 사람들이 지우기 어려워함.  
이유가 있어서, 중요해서 남겨놨겠거니 하고 쌓아두게 돼서 쓸모 없는 코드가 점차 늘어남  
기억은 소스코드관리시스템이 한다.

13. HTML 주석
14. 전역 정보  
근처에 있는 코드에 대한 것만 기술해야하는데 시스템의 전반적인 기술 정보 적는 건 그 부분이랑 관련이 없다는 소리임.

15. 너무 많은 정보  
TMI...설명충..

16. 모호한 관계  
코드와 주석에 대해 1:1 매칭 돼야함. 주석 읽고도 애매하면 그건 안쓰느니만 못함

17. 함수 헤더  
짧은 함수는 짧고 한가지만 수행하고 이름 잘 붙이는 게 더 중요함.

18. 비공개 코드에서 Javadocs  
시스템 내부에 속한 클래스와 함수에 javadocs 생성할 필요 없다.   
javadocs 주석 형식으로 인해 코드가 더러워짐..

<br>

# 5장 - 형식 맞추기
깔끔하고 코드 형식에 맞추기 위해 간단한 규칙을 정해야 한다.

- 중요한 이유
    - 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높은데 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 영향을 미친다.
    - 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계쏙 영향을 미친다.
    - 원래 코드는 사라져도 개발자의 스타일과 규율은 그대로

## 원활한 소통을 장려하는 코드형식
### 세로 : 적절한 세로행 길이 유지
소스 코드는 얼마나 길어야 적당할까?(파일 크기 == 클래스 크기)
- 신문 기사처럼 작성할 것
    - 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경써서 짓는다.
    - 소스 첫 부분 - 고차원 개념, 알고리즘
    - 아래 부분 - 의도를 세세히 묘사
    - 마지막 - 저차원 함수와 세부내역
- 개념은 빈 행으로 분리  
    개행 잘하기 
- 세로 밀집도; 서로 밀접한 코드행은 세로로 가까이 놓여야 한다.
- 연관된 함수간의 수직 거리  
    연관관계와 동작방식 이해를 위해 미로같은 코드를 이리저리 탐색한 적이 있다면 가장 필요로 할 개념.  
    즉, 서로 밀접한 개념은 세로로 가까이 둬야한다.(연관성 : 한 개념을 이해하는 데 다른 개념이 중요한 정도)    
    (관련이 있다면 한 파일에 속해야 돼서 protected 변수 피해야 하는 이유)   
    - 변수 선언 - 사용하는 위치에 최대한 가까이 선언
    - 인스턴스 변수 선언 - 클래스 맨 처음에 선언(자바에서는)
    - 종속 함수 선언 - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치하되, 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치  
    - 개념적 유사성 - 친화도가 높을수록 코드를 가까이 배치  
        - 친화도가 높은 요인
            - 직접적인 종속성 - 한 함수가 다른 함수를 호출해 생김
            - 변수와 그 변수를 사용하는 함수
            - 비슷한 동작을 수행하는 일군의 함수
- 세로 순서 
호출되는 함수를 호출하는 함수보다 나중에 배치

### 가로 : 적절한 가로행 길지
한 행은 가로로 얼마나 길어야 적당할까
- 가로 공백과 밀집도  
공백으로 밀접한 개념과 느슨한 개념을 표현  
    - 할당 연산자 강조를 위함
    - 괄호 안 인수는 별개라는 것을 쉼표로 강조 후 공백으로 분리
    - 연산자 우선순위 강조를 위함

- 가로 정렬  
하지만 변수 유형은 무시하고 변수 이름부터 읽게 되거나 피연산자에만 눈이 감  
정렬하지 않으면 중대한 결정을 찾기 쉬움.  
정렬 필요한 정도로 긴거면 클래스 쪼개야함

- 들여쓰기
- 가짜범위
빈 while문이나 for문..하지만 비추

### 팀규칙
팀 간에 정해야할 규칙. 좋은 소프트웨어 시템은 읽기 쉬운 문서로 이뤄진다.

<br>

# 6장 - 객체와 자료구조
- 변수를 비공개로 정의하는 이유
    - 남들이 변수에 의존하지 않게 하기 위함
    - 변수 타입이나 구현을 맘대로 바꾸고 싶어서
- 조회(get) 함수, 설정(set) 함수를 공개햇 비공개 변수를 외부에 노출하는 이유
- 변수를 private으로 선언해도 각 값마다 조회(get) 함수, 설정(set) 함수를 제공하면 구현을ㅇ ㅚ부로 노출하는 것이다.
- 변수 사이에 함수를 넣어도 구현이 저절로 감춰지지 않는다.  
    구현을 감추려면 추상화가 필요하다.  
    => 클래스  
    : 조회/설정 함수로 변수를 다루는 것 (X)  
    : 추상 인터페이스를 제공해서 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있는 것(X)
- 자료를 세세하게 공개하기보다 추상적인 개념으로 표현하는게 좋다.
- 객체가 포함하는 자료를 표현할 가장 좋은 방법을 고민해야함.

## 자료/객체 비대칭
- 객체 : 자료 공개X(추상화 뒤로 자료를 숨김), 자료를 다루는 함수만 공개
- 자료구조 : 자료 공개O, 함수 제공 X
- EX)
    1. 절차적인/객체지향적인 도형 클래스
    - 절차
        - Geometry 클래스 - 세가지 도형클래스 다룸으로써 도형이 동작하는 방식을 다룸
        - 각자의 도형 클래스 - 간단한 자료 구조
        - 영향도
            - Geometry 클래스에 함수 추가 => 도형 클래스에 영향 X
            - 새 도형 클래스 추가 => Geometry 클래스에 속한 모든 함수 수정 필요
    - 객체지향
        - 다형메서드인 area()만 존재 
        새 도형 추가 => 기존 함수에 아무런 영향 X  
        새 함수 추가 => 도형 클래스 전부 수정. 다 추가해줘야하니까
- 결론
    - 절차적인 코드
        - 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉬움
        - 새로운 자료구조 추가하기 어려움 : 모든 함수 수정 필요
        - 복잡한 시스템에서 새로운 함수 필요한 경우에 적합
    - 객체지향 코드
        - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움
        - 새로운 함수를 추가하기 어려움 : 모든 클래스 수정 필요
        - 복잡한 시스템에서 새로운 자료 타입이 필요한 경우에 적합
    객체지향 코드에서 어려운 변경은 절차적인 코드에선 쉽고
    절차지향 코드에서               객체지향 코드에선 쉽다.

- 디미터 법칙
    - 자신이 조작하는 객체의 속사정을 몰라야한다는 법칙
    - 조회 객체는 자료를 숨기고 함수를 공개한다. =>  함수로 내부 구조를 공개하면 안된다.
    - 클래스 C의 메서드 f는 아래의 객체일 경우에만 호출이 가능하다.(단, 아래의 메서드가 반환하는 객체의 메서드는 호출하면 안됨)
        - 클래스 C
        - f가 생성한 객체
        - f 인수로 넘어온 객체
        - C 인스턴스 변수에 저장된 객체
    - 기차충돌 코드  
    여러 객체가 한줄로 이어진 기차처럼 보이면서 조잡해 보이는 방식이라 피하는 게 좋음
    `final String o = ctxt.getOptions().getScratchDir().getAbsolutePath()`(X)
    =>  
    ```java
    Options opts = ctxt.getOptions();
    File s = opts.getScratchDir();
    final String outputDir = s.getAbsolutePath();
    ```
    - 디미터 법칙 위반 여부
        - 객체 => 위반 O. 내부구조 숨겨야돼서. 비공개변수와 공개함수를 포함하면 해결
        - 자료구조 => 위반 X. 내부구조 노출해야돼서. 함수 없이 공개변수만 포함하면 간단.(단, 단순 자료구조에도 조회/설정 함수 정의하라 요구하는 프레임워크와 표준 존재)
        - 절반은 객체, 절반은 자구인 잡종구조 형태 존재.(중요 기능 수행하는 함수, 공개 변수나 공개 조회/설정 함수-비공개 변수 그대로 노출). 하지만 지양
- 자료 전달 객체(DTO. Data Transfer Object)  
    - 공개 변수만 있고 함수가 없는, 자료 구조체의 전형적인 형태  
    - DB에 저장된 가공되지 않은 정보를 앱 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조
    - ex - DB와 통신하거나 소켓에서 받은 메세지의 구문 분석
    - 일반적인 형태 : Bean 구조
    - 특수한 형태 : 활성 레코드.
        - 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료구조지만 탐색함수도 제공(save, find)
        - DB 테이블이나 다른 소스에서 자료를 직접 변환한 결과
        - 비즈니스 규칙 메서드는 담으면서 내부 자료를 숨기는 객체는 따로 생성해서 자료구조로 취급한다.

## 결론
- 객체
 - 동작 공개, 자료 숨기기   
    =>
    - 기존 동작 변경하지 않으면서 새 객체 타입 추가가 쉬움
    - 기존 객체에 새 동작을 추가하기 어려움
- => 어떤 시스템 구현할 때, 새로운 자료 타입 추가하는 유연성 필요할 시에 적합
- 자료구조
    - 자료 노출
    =>  
    - 기존 자료구조에 새 동작을 추가가 쉬움
    - 기존 함수에 새 자료 구조 추가가 어려움
- => 어떤 시스템 구현할 때, 새로운 동작을 추가하는 유연성 필요할 시에 적합
 
