
## ch11. 시스템

### 시스템 수준에서도 코드를 깨끗하게 유지하는 방법

- 추상화, 모듈화
- 큰 그림을 이해하지 못할지라도 개인이 관리하는 구성요소는 효율적으로 돌아감

### 시스템 제작과 시스템 사용 분리

```java
// 초기화 지연 (lazy initialization) 예시

public Service getService() {
      if (service == null)
          service = new MyServiceImpl(...); // Good enough default for most cases?
      return service;
  }
```

- 이점 : 불필요한 객체 생성을 하지 않아 부하 없음, null 포인터 반환 x
- 단점
    - 시스템은 MyServiceImpl 객체에 대한 의존성을 가지게 되었고 MyServiceImpl의 사용 여부와 관계 없이 무조건 이 의존성을 만족해야 하게 됨
    - 테스트 시 MyServiceImpl 이 무거운 객체라면 단일 책임 원칙 위배
    - 모든 상황에서 MyServiceImpl가 적합한지 모름

설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다. 

ㄴ 의존성을 해소하기 위한 일반적 방식 필요

- main 분리 : 시스템 생성과 시스템 사용을 분리
- 팩토리 : 객체 생성 시점을 애플리케이션이 결정할 필요가 있을 때 Abstract Factory 패턴을 사용하여 생성 코드를 감춘다
    - 추상 팩토리 패턴 : 서로 관련있는 여러 객체를 만들어주는 인터페이스를 제공하는 패턴
- 의존성 주입 : 의존성 주입 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 **단일 책임 원칙**을 지키게 된다.

### 확장

TDD 테스트 주도 개발과 리팩터링으로 얻어지는 깨끗한 코드

- 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 발전할 수 있다.

## ch12. 창발성

단순한 설계 규칙 → 소프트웨어 설계 품질을 크게 높여준다.

- 모든 테스트 실행
    - 낮은 결합도와 높은 응집력을 가지게 됨
- 중복 제거
- 프로그래머의 의도 표현
- 클래스와 메서드 수 최소로 줄이기

작품을 사랑하고 함수와 클래스에 더 주의를 기울이자

## ch13. 동시성

동시성이 필요한 이유 

- coupling을 없애는 전략
- what 과 when 분리

동시성이 필요할 때도 있다. 

- 많은 웹 사이트 정보 수집기, 한 번에 많은 사람이 들어오는 사이트

SRP

- 동시성 코드는 문제가 많이 일어날 수 있기 때문에 다른 코드와 분리해서 관리하자
- 동일한 값을 보장하기 위해 critical section을 synchronized 키워드로 보호하자
    - 이 임계영역의 크기를 줄이고, 캡슐화 하자

ConcurrentHashMap vs HashMap 

- ConcurrentHashMap : 다중 스레드 환경에서 사용해도 안전
- HashMap 보다 거의 모든 상황에서 빠름

  ❓ 동시성 코드를 많이 사용하는지 

권장 사항 

- 공유 객체 하나에는 메서드 하나만 사용
- 동기화 하는 부분을 최대한 작게 만들자 → 크면 스레드간 경쟁이 늘어남, 성능 떨어짐
- 동시성 테스트 시 실패는 스레드 문제로 취급 → 일회성이라고 취급하지 않기
- jiggle(), ConTest를 통한 동시성 테스트

결론 

다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야함

- SRP 준수
- 동시성 오류 이해
    - 여러 스레드가 공유 자료를 조작하거나 자원 풀을 공유할 때 동시성 오류가 발생
- TDD 전략 사용
