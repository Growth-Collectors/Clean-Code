
# 15장 - Junit 들여다보기
- 의도를 명확히 하려면 조건문을 캡슐화해야 한다.  
(조건문을 메서드로 뽑아내 적절한 이름을 붙인다.)  
지역변수가 이미 있으면 다른 이름으로 사용할 것.
- 부정문은 긍정문보다 이해하기 약간 더 어려우니까 긍정문으로 만들어서 조건문을 반전한다.
- 1가지 기능만 수행하는, 함수의 기능에 따른 명확한 이름 부여한다.
- 일관적인 함수 사용 방식을 사용하기
- 모듈은 일련의 분석 함수와 일련의 조합함수로 나뉘는데
- 전체 함수는 위상적으로 정렬했으므로 각 함수가 사용된 직후에 정의된다.  
분석함수가 먼저 나오고 조합함수가 그 뒤를 이어서 나온다.

<br>

# 16장 - SerialDate 리팩터링

- SerialDate  
날짜를 하루 중 시각, 시간대에 무관하게 특정 날짜만 표현하는 자바 클래스.   
(1000분의 1초의 정밀도로 시각을 표현하는 Java.Util.Date는 너무 정밀하다)  
=> 시간에 대한 로직을 짜는 경우가 생기면 뭔가 처음엔 주저하는 기분이 들곤 했던 게 이것 때문이었다.

### 느낀점 :
- 이론이랑 소스를 왔다 갔다 하느라 집중이랑 이해 잘 안되고 읽기 싫었음,,,
- 많은 테스트코드를 직접 수행하고 프로덕트 코드를 고쳐나가는 과정 리스펙..  
나는 이렇게 할 수 있을까..? 이렇게까지 해야 진정한 개발자일까..?  
못할 것 같은데 이 생각 자체가 도태된 생각이긴 하지만..

### 내용 :
- 특정 단위 테스트 메서드는 처음부터 길지 않았고  
처음 구현한 테스트 케이스가 실패하는 바람에 계쏙 추가하게 된 것..!
- 주석 간단화  
라이선스 정보와 저작권을 제외한 변경이력은 소스 코드 제어 도구에서 볼 수 있으므로 지우기
- import문은 .*로 줄이기
- 한 소스 코드에 여러 언어 쓰지 말기
- 변수나 함수명은 정확한 서술적이게 쓰기
- 이름에 추상화 수준 적용하기
- 상수 클래스를 상속하면 MonthConstants.January와 같은 표현을 사용할 필요가 없어지므로 enum으로 정의하기.  
=> 
    - isValidMonthCode, monthCodeToQuarter와 같은 오류 검사코드나 유효성 검증코드가 필요없어짐
    - 모든 enum에 toInt() 접근자를 생성하고 index 필드를 private으로 정의
- 정적 변수/메서드는 DateUtil이라는 새 클래스로 옮기기
- 직렬화를 직접 제어하는 SerialVersionUID 변수를 없애서 자동 제어로 하게 함
- 불필요한 주석이나 안쓰이는 변수나 함수,생성자 및 그에 따른 테스트 케이스는 제거
- 특정 클래스에 속하지 않는 변수나 함수는 그 성격에 맞는 클래스를 생성해서 옮겨놓기  
(일부 추상 메서드를 DayDate 클래스로 끌어올림)
- 기반 클래스(base class. 부모 클래스)는 파생 클래스(derivative. 자식 클래스)를 몰라야 바람직하므로 Abstract Factory 패턴을 적용해서 책임 소재를 확실히 하도록 하기
- 추상 메서드로 위임하는 정적 메서드는 Singleton, Decorator, Abstract Factory 패턴 조합 사용하기
- 상수 변환
- 파일이 커지면 다른 클래스로 빼기
- 인수와 변수 선언에서 final 키워드를 없앤다. 실질적인 가치는 없드면서 코드만 복잡하게 만듦.
- 쓰이는 부분이 한정적이면 함수 합쳐서 간소화
- 중복이 있다면 새 메세드를 생성해서 중복 없애서 메서드를 명확하게 하기ㄴ
- 메서드 인수로 플래그(특히 출력 형식을 선택하는 플래그)는 바람직 못하므로 피하는 편이 좋다.
- 임시 변수 설명(Explaining Temporary Variables)을 사용해서 복잡한 알고리즘을 좀 더 읽기 쉽게 한다.
- 물리적 의존성은 없어도 논리적 의존성이 존재하면 물리적인 의존성을 만들어줘야 한다.

<br>

# 17장 - 냄새와 휴리스틱
냄새라 하니까 별로 어감이 좋지 않다...  
나쁜 코드를 표현하기 위해 어감이 안좋은 것을 의도한거면 성공인 듯..  
나쁜 코드에 대한 포인트들의 정리
(531p - 책 본문에서 각 휴리스틱이 언급되는 참조위치를 보여줌)

## 주석(Comment)
### C1 : 부적절한 정보
다른 시스템(버그 추적 시스템, 이슈 추적 시스템, 기타 기록 관리 시스템)에 저장할 정보
- ex) 소스 코드 관리 시스템에 저장할만한 변경이력(메타 정보(작성자, 최종수정일, SPR 번호 등)는 가능)

### C2 : 쓸모없는
오래되고 엉뚱하고 잘못된 

### C3 : 중복된
코드만으로 충분한 구구절절 설명하는

### C4 : 성의 없는

### C5 : 주석 처리된 코드
누군가에게 필요하거나 다른 사람이 사용할 코드라 생각 들어서 놔두지만  
주석된 코드는 그 자리에 남아서 매일 낡아감

<br>

## 환경(Enviroment)
### E1 : 여러 단계로 빌드해야 한다.
빌드는 하나의 명령으로 전체를 체크아웃 해서 한 명령으로 빌드해서 끝날 수 있어야 한다.

### E2 : 여러 단계로 테스트해야 한다.
모든 단위 테스트 또한 한 명령으로 돌려야 한다.

<br>

## 함수(Function)
### F1 : 너무 많은 인수
인수순서에 따른 좋은 순서 : 0 > 1 > 2 > 4 > ...

### F2 : 출력 인수
함수에서 어떤 상태를 변경해야 한다면 출력인수를 쓰지말고 함수가 속한 객체의 상태를 변경한다.

### F3 : 플래그 인수
boolean인수는 함수가 여러 기능을 수행한다는 명백한 증거

### F4 : 아무도 호출하지 않는 죽은 함수

<br>

## 일반(General)
### G1 : 한 소스 파일에 여러 언어를 사용한다.
ex1) 자바 소스 파일에 XML, HTML, YAML, Javadoc, JavaScript, 영어   
ex2) JSP 파일에 HTML, 자바, 태그 라이브러리 구문, 영어 주석, Javadoc, XML, JavaScript  
소스 파일 하나에 언어 하나만 싸용하는 게 제일 좋다.

### G2 : 당연한 동작을 구현하지 않는다.
- 최소 놀람의 원칙(The Principle of Least Surprise)에 의해   
함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.(놀라지 않도록)
- 당연히 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렴다.

### G3 : 경계를 올바로 처리하지 않는다.
자신의 직관에 의존하지 말고  
모든 경계 조건, 구석진 곳, 예외에 대한 조건을 다 찾고 테스트 하는 테스트 케이스를 작성해야한다.

### G4 : 안전 절차 무시
번거로워도 안전절차는 무조건 해야한다.

### G5 : 중복
- 한번, 단 한번만(Once, and only once)
- 코드에서 중복을 발견할 때마다 추상화할 기회로 간주해라
    - 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라
- 장점
    - 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어나고 다른 사람들도 어휘를 사용하기 쉬워진다.
    - 구현이 빨라지고 오류가 적어진다.
- 똑같은 코드가 여러 차례 나오는 중복은 간단한 함수로 교체
- 알고리즘이 유사하나 코드가 서로 다른 중복은 TEMPLATE METHOD 패턴이나 STRATECY 패턴으로 중복을 제거

### G6 : 추상화 수준이 올바르지 못하다.
- (고차원 개념을 표현하는) 추상 클래스와 (저차원 개념을 표현하는) 파생 클래스를 생성해서  
추상화를 수행하는데 이때 고차원 개념과 저차원 개념을 섞으면 안된다.
    - 추상화 : 저차원 상세 개념에서 고차원 일반 개념을 분리하는 것.
- 추상화로 개념을 분리 할 때는 철저해야 한다.  
- 모든 저차원 개념은 파생 클래스에 넣고 모든 고차원 개념은 기초 클래스에 넣는다.
- ex1) 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안된다.(기초 클래스는 구현 정보에 무지해야 한다.)
- ex2) 개념을 소스파일, 컴포넌트, 모듈, 기초클래스로 분리한다.

### G7 : 기초 클래스가 파생 클래스에 의존한다
기초 클래스가 파생 클래스를 사용한다면 문제가 있따는 것.
- 개념을 기초와 파생 클래스로 나누는 이유  
고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해서 독립성을 보장하기 위함.

### G8 : 과도한 정보

- 부실하게 정의된 모듈
    - 인터페이스가 구질함
    - 간단한 동작 하나에도 온갖 인터페이스가 필요함 => 결합도가 높음

- 잘 정의된 모듈
    - 인터페이스가 아주 작으면서도 많은 동작을 수행할 수 있다.
    - 많은 함수를 제공하지 않음 => 결합도가 낮음
    - 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다.
    - 클래스가 제공하는 메서드 수, 함수가 아는 변수 수, 클래스에 들어있는 인스턴스 변수 수도 작을수록 좋다.
    - 자료, 유틸함수, 상수/임시변수 숨기기
    - 메서드/인스턴스 변수가 넘쳐나는 크래스는 피해
    - 하위 클래스에서 필요하다는 이유로 protected 변수/함수를 덜 생성
    
### G9 : 죽은 코드
실행되지 않는 코드

### G10 : 선언한 위치로부터 수직 분리가 멀리 된 경우
변수와 함수는 사용되는 위치에 가깝게 정의해야 한다.
- 지역 변수 : 처음으로 사용하기 직전에 선언하고 수직으로 가까운 곳에 위치해야한다.
- 비공개 함수
    - 처음으로 호출한 직후에 정의
    - 전체 클래스 범위에 속하지만 정의하는 위치와 호출하는 위치를 가깝게 유지한다.
    - 처음 호출되는 위치에서 조금만 아래 내렸을 때 쉽게 눈에 띄어야함.

### G11 : 일관성 부족
어떤 개념을 특정 방식으로 구현했으면(표기법) 유사한 개념도 같은 방식으로 구현할 것
=> 코드 유지보수에 도움을 줌

### G12 : 잡동사니
- 비어있는 기본 생성자
- 아무도 사용하지 않는 변수
- 아무도 호출하지 않는 함수
- 정보 제공 못하는 주석

### G13 : 인위적 결합
직접적인 상호작용이 없는, 서로 무관한 두 모듈 사이를  
뚜렷한 목적없이 변수/상수/함수를 당장 편하고 잘못된 위치에 넣어서 인위적으로 결합하는 것
- ex) 범용 static 함수나 일반적인 enum가 특정 클래스에 속하는 것

### G14 : 기능 욕심
- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지, 다른 클래스의 것들에 관심을 가져서는 안된다.  
- 메서드가 다른 객체의 참조자와 변경자를 사용해서 그 객체 내용을 조작한다면 메서드가 그 객체 클래스의 범위를 욕심내는 것이다.

### G15 : 선택자 인수
- 선택자 인수는 목적을 까먹게 만들고  
각 선택자 인수가 여러 함수를 하나로 조합하게 만드는 바람에  
큰 함수를 작은 함수 여럿으로 쪼개지 않게 한다.
- 인수를 넘겨서 동작을 선택하는 대신, 새로운 함수를 만드는 편이 좋다.

### G16 : 모호한 의도
코드를 짤 떄 의도를 최대한 분명히 한다.

### G17 : 잘못 지운 책임
- 코드는 개발자에게 편한 함수가 아닌, 독자가 자연스럽게 기대할 위치에 배치하도록 한다.  
- 특별한 이유가 있다면 함수명을 제대로 입력해서 기능에 대한 명시를 확실히 하도록 한다.

### G18 : 부적절한 static 함수
특정 객체와 관련이 없고 모든 정보를 인수에서 가져오더라도 
함수를 재정의할 가능성이 있다면 static이 아닌, 인스턴스 함수로 정의하도록 한다.

### G19 : 서술적이지 않은 변수
계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름(읽기 쉬운, 이해하기 쉬운 변수)을 사용하는 것이 필요하다.

### G20 : 이름과 기능이 일치하지 않는 함수
- 이름을 최대한 서술해서 변경하되, 이름만으로 분명하지 않다면 더 좋은 이름으로 바꾸거나 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

### G21 : 알고리즘 이해 안하는 것
- 1차원적으로 생각할 수 있는 테스트 케이스가 돌아가는 거에만 급급할 것이 아니라    
알고리즘이 올바르다는 사실을 확인하고 이해해야한다.  
- 그러기 위해서는 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 것이 중요하다.

### G22 : 논리적 의존성을 물리적으로 드러내지 않는 것
- 한 모듈이 다른 모듈에 의존하다면 물리적인 의존성도 있어야 한다.
- 의존성이 있다는 것은 물리적으로 티가 나야하고 책임을 확실히 해야한다는 것이다.

### G23 : 다형성보다 if/else 또는 switch/case문을 사용하는 것
선택 유형 하나에는 switch문을 한번만 사용하기 위해
같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해서 switch 문을 대신해야한다.
