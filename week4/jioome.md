### 시스템 수준에서도 코드를 깨끗하게 유지하는 방법

- 추상화, 모듈화
- 큰 그림을 이해하지 못할지라도 개인이 관리하는 구성요소는 효율적으로 돌아감

### 시스템 제작과 시스템 사용 분리

```java
// 초기화 지연 (lazy initialization) 예시

public Service getService() {
      if (service == null)
          service = new MyServiceImpl(...); // Good enough default for most cases?
      return service;
  }
```

- 이점 : 불필요한 객체 생성을 하지 않아 부하 없음, null 포인터 반환 x
- 단점
    - 시스템은 MyServiceImpl 객체에 대한 의존성을 가지게 되었고 MyServiceImpl의 사용 여부와 관계 없이 무조건 이 의존성을 만족해야 하게 됨
    - 테스트 시 MyServiceImpl 이 무거운 객체라면 단일 책임 원칙 위배
    - 모든 상황에서 MyServiceImpl가 적합한지 모름

설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다. 

ㄴ 의존성을 해소하기 위한 일반적 방식 필요

- main 분리 : 시스템 생성과 시스템 사용을 분리
- 팩토리 : 객체 생성 시점을 애플리케이션이 결정할 필요가 있을 때 Abstract Factory 패턴을 사용하여 생성 코드를 감춘다
    - 추상 팩토리 패턴 : 서로 관련있는 여러 객체를 만들어주는 인터페이스를 제공하는 패턴
- 의존성 주입 : 의존성 주입 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 **단일 책임 원칙**을 지키게 된다.

### 확장

TDD 테스트 주도 개발과 리팩터링으로 얻어지는 깨끗한 코드

- 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 발전할 수 있다.
