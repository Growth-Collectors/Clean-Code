
## Ch7. 오류 처리

오류 처리를 잘하는 것은 깨끗한 코드와 연관성이 높음

Try-Catch-Finally 문부터 작성하라

- try-catch 구조로 범위를 정의한 후 TDD를 사용해 필요한 나머지 논리를 추가한다.

오류 코드보다 예외를 사용하자

- 오류 코드 (ex. 로그) 를 통해 오류 처리하면 잊어버리기 쉬움
- 예외를 던지는게 더 깔끔
    - 논리가 오류 처리 코드와 섞이지 않음
    

unchecked 예외 사용  

- 확인된 예외는 OCP 위반
    - 하위 코드를 변경하면 상위 단계 선언부 코드를 전부 고쳐야 한다.
    - throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로캡슐화가 깨짐
    - 확인된 예외도 유용할 때가 있다. 하지만 일반적으로 의존성이 높아 잘 사용하지 않는다.

예외를 던질 때

- 위치, 발생 원인 등 메세지 붙이기

호출자를 고려해 예외 클래스 정의

- 프로그래머에게 가장 중요한 관심사 : 오류를 잡아내는 방법
- 외부 API를 사용할 때 감싸는 클래스를 사용하면 특정 업체가 API를 설계한 방식에 구애받지 않고, 프로그램이 사용하기 편리한 API를 정의할 수 있음

null을 반환하지 마라

- 다른 형태를 반환해라 ex. Collections.emptyList()

null을 전달하지 마라

- 일반적으로 null을 인수로 넘기지 못하도록 하자

### 결론

깨끗한 코드는 읽기도 좋고 안정성이 높아야 함

## Ch8. 경계

학습 테스트

- 간단한 테스트 케이스를 작성해 외부 코드를 익힌다.
- API를 사용하려는 목적에 초점

## Ch9. 단위 테스트

TDD의 법칙 세가지

1. **실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다**
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

테스트 당 개념 하나

- 하나의 개념만 테스트 하기

깨끗한 테스트 F.I.R.S.T

- Fast, Independent, Repeatable, Self-Validation, Timely(테스트는 실제 코드 구현하기 직전에 구현)

테스트는 유연성, 유지보수성, 재사용성 제공

- 가독성이 중요
- 지속적으로 깨끗하게 관리
- 테스트 API를 구현해 DSL을 만들자

## Ch10. 클래스

클래스는 작아야 함

- 여러 책임을 가지면 안됨

단일 책임 원칙

- 클래스 변경할 이유가 하나여야 함 / 책임 한 개

큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 

- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템이 필요한 동작을 수행한다.

응집도가 높다

- 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미
- 클래스가 응집력을 잃는다면 쪼개라
